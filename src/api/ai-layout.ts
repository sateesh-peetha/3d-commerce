// AI Layout Service - Admin AI Layout Change Implementation
// Generated by AI-Orchestration Agent

import { ScreenComposition, LayoutDiff, LayoutChange } from '../types/api';

interface AILayoutRequest {
    prompt: string;
    screen: string;
    currentLayout: ScreenComposition;
}

interface AILayoutResponse {
    newLayout: ScreenComposition;
    diff: LayoutDiff;
    rollbackId: string;
}

// Allowed block IDs from golden_path_spec.md
const ALLOWED_BLOCKS = [
    'header-main-nav', 'prompt-box', 'product-grid', 'footer-main',
    'file-upload', 'model-viewer', 'config-panel', 'material-selector', 'pricing-box',
    'cart-summary', 'order-card', 'kpi-grid', 'printer-status', 'order-queue'
];

// Allowed zones for block placement
const ALLOWED_ZONES = ['header', 'main', 'aside', 'sidebar', 'footer'];

// Validate AI-generated changes
function validateChanges(changes: LayoutChange[]): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    for (const change of changes) {
        switch (change.action) {
            case 'reorder_block':
                if (!ALLOWED_BLOCKS.includes(change.params.block_id)) {
                    errors.push(`Invalid block_id: ${change.params.block_id}`);
                }
                if (typeof change.params.new_order !== 'number' || change.params.new_order < 0) {
                    errors.push(`Invalid new_order: ${change.params.new_order}`);
                }
                break;

            case 'toggle_visibility':
                if (!ALLOWED_BLOCKS.includes(change.params.block_id)) {
                    errors.push(`Invalid block_id: ${change.params.block_id}`);
                }
                if (typeof change.params.visible !== 'boolean') {
                    errors.push(`Invalid visible value: ${change.params.visible}`);
                }
                break;

            case 'change_zone':
                if (!ALLOWED_BLOCKS.includes(change.params.block_id)) {
                    errors.push(`Invalid block_id: ${change.params.block_id}`);
                }
                if (!ALLOWED_ZONES.includes(change.params.new_zone)) {
                    errors.push(`Invalid zone: ${change.params.new_zone}`);
                }
                break;

            default:
                errors.push(`Forbidden action: ${change.action}`);
        }
    }

    return { valid: errors.length === 0, errors };
}

// Apply validated changes to layout
function applyChanges(
    layout: ScreenComposition,
    changes: LayoutChange[]
): ScreenComposition {
    const newBlocks = [...layout.blocks];

    for (const change of changes) {
        const blockIndex = newBlocks.findIndex(b => b.id === change.params.block_id);
        if (blockIndex === -1) continue;

        switch (change.action) {
            case 'reorder_block':
                newBlocks[blockIndex] = {
                    ...newBlocks[blockIndex],
                    order: change.params.new_order
                };
                break;

            case 'toggle_visibility':
                newBlocks[blockIndex] = {
                    ...newBlocks[blockIndex],
                    visible: change.params.visible
                };
                break;

            case 'change_zone':
                newBlocks[blockIndex] = {
                    ...newBlocks[blockIndex],
                    zone: change.params.new_zone
                };
                break;
        }
    }

    // Re-sort by order
    newBlocks.sort((a, b) => a.order - b.order);

    return { ...layout, blocks: newBlocks };
}

// Generate rollback ID
function generateRollbackId(): string {
    return `rollback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Main AI layout processing function
export async function processAILayoutRequest(
    request: AILayoutRequest
): Promise<AILayoutResponse> {
    // Step 1: Call AI model with constrained prompt
    // (In production, this would call the actual AI API)
    const aiResponse = await mockAICall(request);

    // Step 2: Validate changes
    const validation = validateChanges(aiResponse.changes);
    if (!validation.valid) {
        throw new Error(`AI generated invalid changes: ${validation.errors.join(', ')}`);
    }

    // Step 3: Apply changes
    const newLayout = applyChanges(request.currentLayout, aiResponse.changes);

    // Step 4: Generate rollback ID
    const rollbackId = generateRollbackId();

    return {
        newLayout,
        diff: {
            changes: aiResponse.changes,
            before: request.currentLayout,
            after: newLayout
        },
        rollbackId
    };
}

// Mock AI call for testing
async function mockAICall(request: AILayoutRequest): Promise<{ changes: LayoutChange[] }> {
    // This simulates what the AI would return
    // In production, this would be a real API call with guardrails

    if (request.prompt.toLowerCase().includes('compact')) {
        return {
            changes: [
                { action: 'reorder_block', params: { block_id: 'kpi-grid', new_order: 0 } },
                { action: 'reorder_block', params: { block_id: 'order-queue', new_order: 1 } },
                { action: 'toggle_visibility', params: { block_id: 'printer-status', visible: false } }
            ]
        };
    }

    return { changes: [] };
}
